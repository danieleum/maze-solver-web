{"version":3,"sources":["components/Square.jsx","algorithm/LeeAlgo.js","board/MazeSolver.jsx","App.js","index.js"],"names":["Square","props","state","name","this","col","row","start","end","wall","onClick","className","id","Component","leeAlgo","grid","startX","startY","endX","endY","visited","Array","length","fill","map","queue","visitedList","push","Number","MAX_SAFE_INTEGER","current","shift","x","y","dist","distance","xMove","yMove","i","isValid","next","previous","bfs","MazeSolver","squares","newSquare","setState","newBoard","slice","createWall","draw","console","log","doLeeAlgo","rowIndex","square","squareIndex","handleClick","visualizePath","a","promise","Promise","resolve","setTimeout","node","document","getElementById","style","backgroundColor","visualizeShortestPath","path","curr","window","alert","App","class","ReactDOM","render"],"mappings":"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","file":"static/js/main.ed958205.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Square.css';\n\nexport default class Square extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  render() {\n    let {col, row, start, end, wall, onClick} = this.props;\n    let name;\n    if (start) {\n      name = 'square starting';\n    } else if (end) {\n      name = 'square ending';\n    } else if (wall) {\n      name = 'square wall';\n    } else {\n      name = 'square';\n    }\n\n    return <div onClick={() => onClick(row, col)} className={`${name}`} id={`square-${row}-${col}`}></div>;\n  }\n}\n","\n// grid => initial grid... tells us where the walls are\n// startX & startY => starting node index\n// endX & endY => ending node index\nexport function leeAlgo (grid, startX, startY, endX, endY) {\n  let visited = bfs(grid, startX, startY, endX, endY);\n  return visited;\n}\n\n// grid => initial grid... tells us where the walls are\n// startX & startY => starting node index\n// endX & endY => ending node index\n\n\nfunction bfs (grid, startX, startY, endX, endY) {\n  // matrix to track visited (maybe not needed?)\n  // 0 -> unvisited\n  // 1 -> visited\n  const visited = Array(grid.length).fill(0).map(row => new Array(grid[0].length).fill(0));\n  \n  // empty queue\n  let queue = [];\n  \n  // maybe have a list that keeps track of the visited nodes... append the current node that we are examining\n  let visitedList = [];\n  \n  // mark source square as visited in matrix and list\n  visited[startX][startY] = 1;\n  visitedList.push(grid[startX][startY]);\n  \n  // enqueue source square\n  queue.push(grid[startX][startY]);\n\n  // variable to store length of longest?? path from source to destination\n  let min = Number.MAX_SAFE_INTEGER;\n\n  // while queue is not empty\n  while (queue.length !== 0) {\n    //    dequeue front node \n    let current = queue.shift();\n\n    /*\n    <Square \n      col={squareIndex} \n      row={rowIndex} \n      key={squareIndex} \n      start={start} \n      end={end} \n      wall={wall} \n      distance=0\n      onClick={(row, col) => this.handleClick(row, col)}>\n    </Square>\n    */\n    \n    //    get node coordinates and distance (do we need distance?) \n    let x = current.row;\n    let y = current.col;\n    let dist = current.distance;\n    \n    //    if node is destination, update the distance tracking variable and return ??\n    if (x === endX && y === endY) {\n      min = dist;\n      return visitedList;\n    }\n\n    // x and y possible movements\n    const xMove = [-1, 0, 0, 1];\n    const yMove = [0, -1, 1, 0];\n    \n    //    check for the 4 possible movements from current cell\n    for (let i = 0; i < 4; i++) {\n      // check if movement is valid \n      if (isValid(grid, visited, x + xMove[i], y + yMove[i])) {\n        // mark the nodes as visited\n        visited[x + xMove[i]][y + yMove[i]] = 1;\n\n        let next = grid[x + xMove[i]][y + yMove[i]];\n        \n       \n        // update distance \n        next.distance++;\n        // enqueue the node representing valid movement \n        queue.push(next);\n\n        visitedList.push(next);\n        // updating the previous node\n        next.previous = current;\n      }\n    }\n  }\n  // if path not found returns empty list\n  return [];\n}\n\n// checks that square coordinates are in matrix bounds and non-negative\nfunction isValid(grid, visited, row, col) {\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col].wall || visited[row][col]) {\n    return false;\n  }\n\n  return true;\n}\n\n\n\n\n\n\n","import React, {Component} from 'react';\n\nimport Square from '../components/Square';\nimport * as leeAlgo from '../algorithm/LeeAlgo';\n\nimport './MazeSolver.css';\n\nconst start = 0;\nconst end = 19;\n/*\nconst rows = 20;\nconst cols = 20;\n*/\n\nexport default class MazeSolver extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      squares: [],\n    };\n  }\n\n\n  componentDidMount() {\n    const squares = [];\n    for (let row = 0; row < 20; row++) {\n      const current = [];\n      for (let col = 0; col < 20; col++) {\n        const newSquare = {\n          row: row,\n          col: col,\n          distance: 0,\n          wall: false,\n          previous: null,\n          start: row === start && col === start,\n          end: row === end && col === end\n        }\n        current.push(newSquare);\n      }\n      squares.push(current);\n    }\n    this.setState({squares});\n  }\n\n  handleClick(row, col) {\n    let newBoard = createWall(this.state.squares, row, col);\n    this.setState({squares: newBoard});\n  }\n\n  doLeeAlgo() {\n    let grid = this.state.squares;\n    let visited  = leeAlgo.leeAlgo(grid, start, start, end, end);\n    draw(visited, grid);\n  }\n\n  render() {\n    const {squares} = this.state;\n    console.log(squares)\n    console.log(squares.length)\n    /*\n    const check = Array(squares.length).fill(0).map(row => new Array(squares[0].length).fill(0));\n    console.log(check);\n    */\n\n    return (\n      <div className=\"board\">\n        \n        <div>\n          <button onClick={() => this.doLeeAlgo()}>\n            Check the maze\n          </button>\n        </div>\n        {squares.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex}>\n              {row.map((square, squareIndex) => {\n                const {start, end, wall} = square;\n                return (\n                  <Square\n                    col={squareIndex}\n                    row={rowIndex}\n                    key={squareIndex}\n                    start={start}\n                    end={end}\n                    wall={wall}\n                    onClick={(row, col) => this.handleClick(row, col)}>\n                  </Square>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n\nfunction createWall (squares, row, col) {\n  let newBoard = squares.slice();\n  let current = newBoard[row][col];\n  /*\n  let wallSquare = {\n    ...current,\n    wall: !current.wall\n  }\n  */\n  current.wall = !current.wall;\n  newBoard[row][col] = current;\n  return newBoard;\n}\n\nasync function visualizePath(visited) {\n  let promise;\n  for (let i = 0; i < visited.length; i++) {\n    promise = new Promise(resolve => setTimeout(() => {\n        const node = visited[i];\n        const curr = document.getElementById(`square-${node.row}-${node.col}`).style;\n        curr.backgroundColor = \"brown\";\n        resolve();\n      }, 10 * i));\n  }\n  return promise;\n}\n\nfunction visualizeShortestPath(grid) {\n  let path = [];\n  let node = grid[end][end];\n  path.push(node);\n  while (node.previous !== null) {\n    path.push(node.previous);\n    node = node.previous;\n  }\n  for (let i = 0; i < path.length; i++) {\n    setTimeout(() => {\n      let curr = path[i];\n      let style = document.getElementById(`square-${curr.row}-${curr.col}`).style;\n      style.backgroundColor = \"yellow\";\n    }, 10 * i);\n  }\n}\n\nasync function draw(visited, grid) {\n  if (visited.length !== 0) {\n    await visualizePath(visited);\n    visualizeShortestPath(grid);\n  } else {\n    window.alert(\"Maze cannot be solved. Please create a valid maze.\");\n  }\n}","import MazeSolver from './board/MazeSolver';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div class=\"nav-bar\">\n        <h1> Maze Solver </h1>\n      </div>\n      <MazeSolver />\n    </div>\n  );\n}\n\n\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(<App />,document.getElementById('root'));\n\n"],"sourceRoot":""}